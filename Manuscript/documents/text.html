<p style='text-align: center;'><span style='font-weight: normal;color:rgb(0, 0, 0);font-family:Kefa;line-height:72pt;font-size: 60pt;'>Introduction</span></p><p style='text-align: left;'><br /><span style='font-weight: normal;color:rgb(0, 0, 0);font-family: Minion Pro;line-height: 14.4pt;font-size: 12pt;'>One of the most distinctive aspects of Flutter is its aggressive composability. Widgets are built by composing other widgets, which are themselves built out of progressively more basic widgets. For example, Padding is a widget rather than a property of other widgets. As a result, user interfaces built with Flutter consist of many, many widgets.</span><br /><br /><span style='font-weight: normal;color:rgb(0, 0, 0);font-family: Minion Pro;line-height: 14.4pt;font-size: 12pt;'>The widget building recursion bottoms out in RenderObjectWidgets, which are widgets that create nodes in the underlying render tree. The render tree is a data structure that stores the geometry of the user interface, which is computed during layout and used during painting and hit testing. Most Flutter developers do not author render objects directly but instead manipulate the render tree using widgets.</span><br /><br /><span style='font-weight: normal;color:rgb(0, 0, 0);font-family: Minion Pro;line-height: 14.4pt;font-size: 12pt;'>In order to support aggressive composability at the widget layer, Flutter uses a number of efficient algorithms and optimizations at both the widget and render tree layers, which are described in the following subsections.</span></p>